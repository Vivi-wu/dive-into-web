---
title:  "HTTP 网络协议"
category: Other
---
web 资源的传输依赖于网络传输协议。目前 HTTP 1.1 为互联中的主要协议，而
HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新。

### 编码

HTTP/1.x 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。

HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用**二进制编码**。

<!--more-->

### 多路复用

HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接。浏览器为了控制资源，会对单个域名有 6-8 的个数限制，超过限制的请求会被挂起等待了一段时间。

HTTP/2中：

+ 同域名下所有通信都在**单个连接**上完成。
+ 单个连接可以承载任意数量的双向数据流。
+ 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

### 头部压缩

HTTP 每一次通信都会携带一组头部，用于描述这次通信的的资源、浏览器属性、cookie 等。

HTTP/2对消息头采用HPACK（专为http2头部设计的压缩格式）进行压缩传输，而HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费带宽资源。

具体实现：

+ 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对；
+ 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
+ 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

## web 缓存

对于前端开发者来说，我们主要跟浏览器中的缓存打交道。关于缓存资源的问题，都仅仅针对GET请求。而对于POST, DELETE, PUT这类行为性操作通常不做任何缓存。

HTTP通过缓存将服务器资源的副本保留一段时间，这段时间称为**新鲜度限值**。这在一段时间内请求相同资源不会再通过服务器。

HTTP协议中 `Cache-Control` 和 `Expires`可以用来设置新鲜度的限值，前者是 **HTTP1.1** 中新增的响应头，后者是 **HTTP1.0** 中的响应头。二者所做的事时都是相同的，但由于Cache-Control使用的是**相对时间**，而Expires可能存在客户端与服务器端时间不一样的问题，所以我们更倾向于选择 Cache-Control。

Cache-Control 不仅仅可以在响应头中设置，还可以在请求头中设置。

可能设置的属性值有：

+ max-age（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了
+ public 指定响应可以在代理缓存中被缓存，于是可以被多用户共享。如果没有明确指定private，则默认为public。
+ private 响应只能在私有缓存中被缓存，不能放在代理缓存上。对一些用户信息敏感的资源，通常需要设置为private。
+ no-cache 表示必须先与服务器确认资源是否被更改过（依靠If-None-Match和Etag），然后再决定是否使用本地缓存。
+ no-store 绝对禁止缓存任何资源，也就是说每次用户请求资源时，都会向服务器发送一个请求，每次都会下载完整的资源。通常用于机密性资源。

浏览器或代理缓存中缓存的资源过期了，并不意味着它和原始服务器上的资源有实际的差异，仅仅意味着到了要进行核对的时间了。这种情况被称为服务器再验证。

如果资源发生变化，则需要取得新的资源，并在缓存中替换旧资源。如果资源没有发生变化，缓存只需要获取新的响应头，和一个新的过期时间，对缓存中的资源过期时间进行更新即可。 HTTP1.1 推荐使用的验证方式是 `If-None-Match` / `Etag` 对应 Request Headers 和 Response Headers，在 HTTP1.0 中则使用 If-Modified-Since/Last-Modified

